/*
 * socket网络编程训练
 */

//client.c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <linux/in.h>
#include <strings.h>
#include <sys/types.h>
#include <sys/socket.h>

int main(void)
{
	int cfd;   //文件描述符
	int recbytes;
	int sin_size;
	char buffer[1024] = {0};           //接收缓冲区
	struct sockaddr_in s_add, c_add;   //存储服务端和本端的ip、端口等信息结构体
	unsigned short portnum = 0x8888;   //服务端使用的通信端口，可以更改，需和服务端相同

	printf("Hello, welcome to client!\n\r");

	//建立socket，使用因特网，使用TCP方式传输
	cfd = socket(AF_INET, SOCK_STREAM, 0);   
	if (-1 == cfd) {
		printf("socket fail!\n\r");
		return -1;
	}
	printf("socket ok!\n\r");

	//构造服务器端的ip和端口信息，具体结构体可以查资料
	bzero(&s_add, sizeof(struct sockaddr_in));
	s_add.sin_family = AF_INET;
	s_add.sin_addr.s_addr = inet_addr("172.16.89.204"); //ip转换为4字节整形，使用时可以根据服务端ip进行修改
	s_add.sin_port = htons(portnum);   /* 这里htons是将short型数据字节序由主机型转换为网络型，其实就是 
    	将2字节数据的前后两个字节倒换，和对应的ntohs效果、实质相同，只不过名字不同。htonl和ntohl是 
    	操作的4字节整形。将0x12345678变为0x78563412，名字不同，内容两两相同，一般情况下网络为大端， 
   		PPC的cpu为大端，x86的cpu为小端，arm的可以配置大小端，需要保证接收时字节序正确。 
 	*/ 

	//这里打印出来的是小端的，和我们平时看到的是相反的
	printf("s_addr = %#x, port = %#x \n\r", s_add.sin_addr.s_addr, s_add.sin_port);

	//客户端连接服务器，参数依次为socket文件描述符，地址信息，地址结构大小
	if (-1 == connect(cfd, (struct sockaddr *)(&s_add), sizeof(struct sockaddr))) {
		printf("connect fail!\n\r");
		return -1;
	}
	printf("connect ok!\n\r");

	//连接成功，从服务端接收字符
	if (-1 == (recbytes = read(cfd, buffer, 1024))) {
		printf("read data fail !\n\r");
		return -1;
	}
	printf("read ok!\n\r REC:\n\r");

	buffer[recbytes] = '\0';
	printf("buffer: %s\n\r", buffer);

	getchar();   //此句为是程序暂停在此处，可以使用netstat查看当前的连接
	close(cfd);  //关闭连接，本次通信完成
	
	return 0;
}



